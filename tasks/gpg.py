from __future__ import absolute_import, print_function

from tempfile import NamedTemporaryFile
from textwrap import dedent

from os import path

from invoke import task
from invoke.exceptions import Exit


KEY_EMAIL = "salt@jlindsey.me"


@task
def gen_keys(c):
    """
    Bootstrap the GPG keys for Salt encrypted pillars
    """
    c.config.run.echo = True

    if path.exists("etc/gpgkeys"):
        raise Exit("GPG key dir already exists, refusing to overwrite")

    with NamedTemporaryFile() as f:
        keyopts = f"""
            Key-Type: default
            Key-Length: 4096
            Subkey-Type: default
            Subkey-Length: 4096
            Name-Real: Salt
            Name-Comment: SaltStack encryption key
            Name-Email: {KEY_EMAIL}
            Expire-Date: 0
            %no-protection
            %commit"""
        keyopts = dedent(keyopts).strip()
        print(keyopts)
        f.write(keyopts.encode())
        f.seek(0)

        with c.cd("etc"):
            c.run("mkdir -p gpgkeys")
            c.run("chmod 0700 gpgkeys")
            c.run(f"gpg --homedir gpgkeys --batch --gen-key {f.name}")


@task
def export_pub_key(c):
    """
    Export the GPG public key generated by the gen-keys task to stdout
    """
    with c.cd("etc"):
        c.run(f"gpg --homedir gpgkeys --armor --export {KEY_EMAIL}")


@task
def encrypt(c, payload):
    """
    Encrypt the provided string to stdout with the GPG key generated by the gen-keys task.

    This uses your system GPG ring - NOT the one in etc/gpgkeys. It expects that
    you have imported the public key into your ring from export-pub-key.
    """

    c.run(
        f'gpg --armor --batch --trust-model always -e -r {KEY_EMAIL} <<< "{payload}"',
        pty=True,
    )
